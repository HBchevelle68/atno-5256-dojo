id: "atno5256"
name: ATNO-5256
type: welcome
award:
  emoji: ðŸ¤‘
modules:
- id: "hello"
- id: "paths"
- id: "commands"
- id: "man"
- id: "globbing"
- id: "piping"
- id: "variables"
- id: "processes"
- id: "permissions"
- id: "users"
- id: "chaining"
- id: "path"
- id: shellcode-injection
  name: Shellcode Injection
  description: |
    Welcome to **Shellcode Injection**, the deep dive into the choreography of code execution, where you don't just tap into the rhythm of a system, but you take the lead, guiding the entire ensemble of processes, threads, and instructions.
    
    Once the gates of execution are breached, what follows?
    Is it the end of the battle, or merely the beginning of a symphony?
    How does one communicate with the very core of a machine, dictating its every move, turning threats into opportunities, limitations into launching pads?
    
    For the hackers among us, the dance begins with shellcode.
    But mastering this dance isn't about merely memorizing steps; it's about improvisation, anticipation, and adaptation.
    
    Throughout this module, you'll dive deep into:
    - **Execution Environments**: Navigate the different arenas your shellcode might be thrown into, from the predictable world of memory allocation to the wild terrains of stack-based randomness.
    - **Filters & Constraints**: Often, the dance floor isn't clear. There might be traps set up, from the dreaded 'H' bytes checker to the cunning bubblesort sorter, ready to trip your shellcode up. Can you weave through these obstacles, adjusting your steps on the fly?
    - **Shellcoding Techniques**: With the right steps, even the most intricate of routines can be bypassed. Master techniques such as nop sleds, self-modifying code, position-independent practices, and the cunning of two-stage shellcodes to remain unstoppable.
    
    Dancing with a processor isn't just about knowing the steps, but understanding the language and semantics of each instruction.
    While you'll have the stage to yourself, we ensure you're never alone on this journey.
    Equip yourself with these invaluable scrolls of wisdom:
    - [x64.syscall.sh](https://x64.syscall.sh): Your cheat sheet for syscalls. A glance here, and you're always ahead.
    - [Syscalls Manpage](https://man7.org/linux/man-pages/man2/syscalls.2.html): Understand not just the calls, but their deeper implications.
    - [Felix Cloutier](https://www.felixcloutier.com/x86/): Dive into the heartbeats of instructions, ensuring you're always in step.    
    - [x86asm Reference](http://ref.x86asm.net/coder64.html): Decode the bytes into moves, turning the tables on any challenge.

    As you embark on this journey, remember, it's not just about taking control; it's about finesse, elegance, and the joy of the dance.
    In the vast assembly halls of x64, the processor awaits your cue.
    So, put on your dancing shoes, and let's speak the language of the processor!
  challenges:
  - id: level-1
    name: level1
    description: Write and execute shellcode to read the flag!
  - id: level-2
    name: level2
    description: Write and execute shellcode to read the flag, but a portion of your input is randomly skipped.
  - id: level-3
    name: level3
    description: Write and execute shellcode to read the flag, but your inputted data is filtered before execution.
  - id: level-4
    name: level4
    description: Write and execute shellcode to read the flag, but your inputted data is filtered before execution.
  - id: level-5
    name: level5
    description: Write and execute shellcode to read the flag, but the inputted data cannot contain any form of system call
      bytes (syscall, sysenter, int), can you defeat this?
  - id: level-6
    name: level6
    description: Write and execute shellcode to read the flag, but the inputted data cannot contain any form of system call
      bytes (syscall, sysenter, int), this challenge adds an extra layer of difficulty!
  - id: level-7
    name: level7
    description: Write and execute shellcode to read the flag, but all file descriptors (including stdin, stderr and stdout!)
      are closed.
  - id: level-8
    name: level8
    description: Write and execute shellcode to read the flag, but you only get 18 bytes.
  - id: level-9
    name: level9
    description: Write and execute shellcode to read the flag, but your input has data inserted into it before being executed.
  - id: level-10
    name: level10
    description: Write and execute shellcode to read the flag, but your input is sorted before being executed!
  - id: level-11
    name: level11
    description: Write and execute shellcode to read the flag, but your input is sorted before being executed and stdin is
      closed.
  - id: level-12
    name: level12
    description: Write and execute shellcode to read the flag, but every byte in your input must be unique.
  - id: level-13
    name: level13
    description: Write and execute shellcode to read the flag, but this time you only get 12 bytes!
  - id: level-14
    name: level14
    description: "Write and execute shellcode to read the flag, but this time you only get 6 bytes :)"
- id: reverse-engineering
  name: Reverse Engineering
  description: ""
  challenges:
  - id: level-1-0
    name: level1.0
    description: Reverse engineer this challenge to find the correct license key.
  - id: level-1-1
    name: level1.1
    description: Reverse engineer this challenge to find the correct license key.
  - id: level-2-0
    name: level2.0
    description: Reverse engineer this challenge to find the correct license key, but your input will be modified somehow
      before being compared to the correct key.
  - id: level-2-1
    name: level2.1
    description: Reverse engineer this challenge to find the correct license key, but your input will be modified somehow
      before being compared to the correct key.
  - id: level-3-0
    name: level3.0
    description: Reverse engineer this challenge to find the correct license key, but your input will be modified somehow
      before being compared to the correct key.
  - id: level-3-1
    name: level3.1
    description: Reverse engineer this challenge to find the correct license key, but your input will be modified somehow
      before being compared to the correct key.
  - id: level-4-0
    name: level4.0
    description: Reverse engineer this challenge to find the correct license key, but your input will be modified somehow
      before being compared to the correct key.
  - id: level-4-1
    name: level4.1
    description: Reverse engineer this challenge to find the correct license key, but your input will be modified somehow
      before being compared to the correct key.
  - id: level-5-0
    name: level5.0
    description: Reverse engineer this challenge to find the correct license key, but your input will be modified somehow
      before being compared to the correct key.
  - id: level-5-1
    name: level5.1
    description: Reverse engineer this challenge to find the correct license key, but your input will be modified somehow
      before being compared to the correct key.
  - id: level-6-0
    name: level6.0
    description: Reverse engineer this challenge to find the correct license key, but your input will be modified somehow
      before being compared to the correct key.
  - id: level-6-1
    name: level6.1
    description: Reverse engineer this challenge to find the correct license key, but your input will be modified somehow
      before being compared to the correct key.
  - id: level-7-0
    name: level7.0
    description: Reverse engineer this challenge to find the correct license key, but your input will be modified somehow
      before being compared to the correct key.
  - id: level-7-1
    name: level7.1
    description: Reverse engineer this challenge to find the correct license key, but your input will be modified somehow
      before being compared to the correct key.
  - id: level-8-0
    name: level8.0
    description: Reverse engineer this challenge to find the correct license key, but your input will be modified somehow
      before being compared to the correct key.
  - id: level-8-1
    name: level8.1
    description: Reverse engineer this challenge to find the correct license key, but your input will be modified somehow
      before being compared to the correct key.
  - id: level-9-0
    name: level9.0
    description: Reverse engineer this challenge to find the correct license key, but your input will be modified somehow
      before being compared to the correct key. This challenge allows you to patch 5 bytes in the binary.
  - id: level-9-1
    name: level9.1
    description: Reverse engineer this challenge to find the correct license key, but your input will be modified somehow
      before being compared to the correct key. This challenge allows you to patch 5 bytes in the binary.
  - id: level-10-0
    name: level10.0
    description: Reverse engineer this challenge to find the correct license key, but your input will be modified somehow
      before being compared to the correct key. This challenge allows you to patch 1 byte in the binary.
  - id: level-10-1
    name: level10.1
    description: Reverse engineer this challenge to find the correct license key, but your input will be modified somehow
      before being compared to the correct key. This challenge allows you to patch 1 byte in the binary.
  - id: level-11-0
    name: level11.0
    description: Reverse engineer this challenge to find the correct license key, but your input will be modified somehow
      before being compared to the correct key. This challenge allows you to patch 2 bytes in the binary, but performs an
      integrity check afterwards.
  - id: level-11-1
    name: level11.1
    description: Reverse engineer this challenge to find the correct license key, but your input will be modified somehow
      before being compared to the correct key. This challenge allows you to patch 2 bytes in the binary, but performs an
      integrity check afterwards.
  - id: level-12-0
    name: level12.0
    description: |-
      We're about to dive into reverse engineering obfuscated code!
      To better prepare you for the journey ahead, this challenge is a very straightforward crackme, but using slightly different code, memory layout, and input format.
      We will progressively obfuscate this in future levels, but this level should be a freebie!
  - id: level-12-1
    name: level12.1
    description: |-
      We're about to dive into reverse engineering obfuscated code!
      To better prepare you for the journey ahead, this challenge is a very straightforward crackme, but using slightly different code, memory layout, and input format.
      We will progressively obfuscate this in future levels, but this level should be a freebie!
  - id: level-13-0
    name: level13.0
    description: |-
      Let's dive into reverse engineering obfuscated code!
      This challenge is using VM-based obfuscation: reverse engineer the custom emulator and architecture to understand how to get the flag!
      If you are clever, you won't need to reverse _too_ much VM code.
  - id: level-13-1
    name: level13.1
    description: |-
      Let's dive into reverse engineering obfuscated code!
      This challenge is using VM-based obfuscation: reverse engineer the custom emulator and architecture to understand how to get the flag!
      If you are clever, you won't need to reverse _too_ much VM code.
  - id: level-14-0
    name: level14.0
    description: |-
      Let's dive into reverse engineering obfuscated code!
      This challenge is using VM-based obfuscation: reverse engineer the custom emulator and architecture to understand how to get the flag!
      If you are clever, you won't need to reverse _too_ much VM code.
  - id: level-14-1
    name: level14.1
    description: |-
      Let's dive into reverse engineering obfuscated code!
      This challenge is using VM-based obfuscation: reverse engineer the custom emulator and architecture to understand how to get the flag!
      If you are clever, you won't need to reverse _too_ much VM code.
  - id: level-15-0
    name: level15.0
    description: |-
      Let's dive into reverse engineering obfuscated code!
      This challenge is using VM-based obfuscation: reverse engineer the custom emulator and architecture to understand how to get the flag!
      If you are clever, you won't need to reverse _too_ much VM code.
  - id: level-15-1
    name: level15.1
    description: |-
      Let's dive into reverse engineering obfuscated code!
      This challenge is using VM-based obfuscation: reverse engineer the custom emulator and architecture to understand how to get the flag!
      If you are clever, you won't need to reverse _too_ much VM code.
  - id: level-16-0
    name: level16.0
    description: |-
      Let's continue deeper in reverse engineering obfuscated code!
      This challenge is using VM-based obfuscation: reverse engineer the custom emulator and architecture to understand how to get the flag!
  - id: level-16-1
    name: level16.1
    description: |-
      Let's continue deeper inreverse engineering obfuscated code!
      This challenge is using VM-based obfuscation: reverse engineer the custom emulator and architecture to understand how to get the flag!
  - id: level-17-0
    name: level17.0
    description: "This challenge is using VM-based obfuscation: reverse engineer the custom emulator and architecture to understand\
      \ how to get the flag!"
  - id: level-17-1
    name: level17.1
    description: "This challenge is using VM-based obfuscation: reverse engineer the custom emulator and architecture to understand\
      \ how to get the flag!"
  - id: level-18-0
    name: level18.0
    description: "This challenge is using VM-based obfuscation: reverse engineer the custom emulator and architecture to understand\
      \ how to get the flag!"
  - id: level-18-1
    name: level18.1
    description: "This challenge is using VM-based obfuscation: reverse engineer the custom emulator and architecture to understand\
      \ how to get the flag!"
  - id: level-19-0
    name: level19.0
    description: |-
      This challenge is using VM-based obfuscation: reverse engineer the custom emulator and architecture to understand how to get the flag!
      This is a full end-to-end obfuscated challenge, like you might see in real-world obfuscated code!
  - id: level-19-1
    name: level19.1
    description: |-
      This challenge is using VM-based obfuscation: reverse engineer the custom emulator and architecture to understand how to get the flag!
      This is a full end-to-end obfuscated challenge, like you might see in real-world obfuscated code!
  - id: level-20-0
    name: level20.0
    description: 'Reverse engineer this custom emulator and architecture to understand how to get the flag! '
  - id: level-20-1
    name: level20.1
    description: 'Reverse engineer this custom emulator and architecture to understand how to get the flag! '
  - id: level-21-0
    name: level21.0
    description: Reverse engineer this custom emulator and architecture, and write your own custom shellcode to get the flag.
  - id: level-21-1
    name: level21.1
    description: Reverse engineer this custom emulator and architecture, and write your own custom shellcode to get the flag.
  - id: level-22-0
    name: level22.0
    description: |-
      Reverse engineer this custom emulator and architecture, and write your own custom shellcode to get the flag, with a twist.
      This is the final boss.
      Are you a true Yan-head?
  - id: level-22-1
    name: level22.1
    description: |-
      Reverse engineer this custom emulator and architecture, and write your own custom shellcode to get the flag, with a twist.
      This is the final boss.
      Are you a true Yan-head?
- id: memory-errors
  name: Memory Errors
  description: ""
  challenges:
  - id: level-1-0
    name: level1.0
    description: Overflow a buffer on the stack to set the right conditions to obtain the flag!
  - id: level-1-1
    name: level1.1
    description: Overflow a buffer on the stack to set the right conditions to obtain the flag!
  - id: level-2-0
    name: level2.0
    description: Overflow a buffer on the stack to set trickier conditions to obtain the flag!
  - id: level-2-1
    name: level2.1
    description: Overflow a buffer on the stack to set trickier conditions to obtain the flag!
  - id: level-3-0
    name: level3.0
    description: Overflow a buffer and smash the stack to obtain the flag!
  - id: level-3-1
    name: level3.1
    description: Overflow a buffer and smash the stack to obtain the flag!
  - id: level-4-0
    name: level4.0
    description: Overflow a buffer and smash the stack to obtain the flag, but this time bypass a check designed to prevent
      you from doing so!
  - id: level-4-1
    name: level4.1
    description: Overflow a buffer and smash the stack to obtain the flag, but this time bypass a check designed to prevent
      you from doing so!
  - id: level-5-0
    name: level5.0
    description: Overflow a buffer and smash the stack to obtain the flag, but this time bypass another check designed to
      prevent you from doing so!
  - id: level-5-1
    name: level5.1
    description: Overflow a buffer and smash the stack to obtain the flag, but this time bypass another check designed to
      prevent you from doing so!
  - id: level-6-0
    name: level6.0
    description: Overflow a buffer and smash the stack to obtain the flag, but this time bypass another check designed to
      prevent you from doing so!
  - id: level-6-1
    name: level6.1
    description: Overflow a buffer and smash the stack to obtain the flag, but this time bypass another check designed to
      prevent you from doing so!
  - id: level-7-0
    name: level7.0
    description: Overflow a buffer and smash the stack to obtain the flag, but this time in a position independent (PIE) binary!
  - id: level-7-1
    name: level7.1
    description: Overflow a buffer and smash the stack to obtain the flag, but this time in a position independent (PIE) binary!
  - id: level-8-0
    name: level8.0
    description: Overflow a buffer and smash the stack to obtain the flag, but this time in a position independent (PIE) binary
      with an additional check on your input.
  - id: level-8-1
    name: level8.1
    description: Overflow a buffer and smash the stack to obtain the flag, but this time in a position independent (PIE) binary
      with an additional check on your input.
  - id: level-9-0
    name: level9.0
    description: Overflow a buffer and smash the stack to obtain the flag, but this time in a PIE binary with a stack canary.
      Be warned, this requires careful and clever payload construction!
  - id: level-9-1
    name: level9.1
    description: Overflow a buffer and smash the stack to obtain the flag, but this time in a PIE binary with a stack canary.
      Be warned, this requires careful and clever payload construction!
  - id: level-10-0
    name: level10.0
    description: Overflow a buffer and leak the flag. Be warned, this requires careful and clever payload construction!
  - id: level-10-1
    name: level10.1
    description: Overflow a buffer and leak the flag. Be warned, this requires careful and clever payload construction!
  - id: level-11-0
    name: level11.0
    description: Overflow a buffer and leak the flag. Be warned, this requires careful and clever payload construction!
  - id: level-11-1
    name: level11.1
    description: Overflow a buffer and leak the flag. Be warned, this requires careful and clever payload construction!
  - id: level-12-0
    name: level12.0
    description: Defeat a stack canary in a PIE binary by utilizing a bug left in the binary.
  - id: level-12-1
    name: level12.1
    description: Defeat a stack canary in a PIE binary by utilizing a bug left in the binary.
  - id: level-13-0
    name: level13.0
    description: Leak data left behind unintentionally by utilizing clever payload construction.
  - id: level-13-1
    name: level13.1
    description: Leak data left behind unintentionally by utilizing clever payload construction.
  - id: level-14-0
    name: level14.0
    description: Leak data left behind unintentionally to defeat a stack canary in a PIE binary.
  - id: level-14-1
    name: level14.1
    description: Leak data left behind unintentionally to defeat a stack canary in a PIE binary.
  - id: level-15-0
    name: level15.0
    description: Defeat a stack canary in a PIE binary by utilizing a network-style fork server in the target binary.
  - id: level-15-1
    name: level15.1
    description: Defeat a stack canary in a PIE binary by utilizing a network-style fork server in the target binary.
- id: dynamic-allocator-misuse
  name: Dynamic Allocator Misuse
  description: |
    The glibc heap consists of many components distinct parts that balance performance and security.
    In this introduction to the heap, the thread caching layer, `tcache` will be targeted for exploitation.
    `tcache` is a fast thread-specific caching layer that is often the first point of interaction for programs working with dynamic memory allocations.

  challenges:
  - id: level-1-0
    name: level1.0
    description: "Exploit a use-after-free vulnerability to get the flag."
  - id: level-1-1
    name: level1.1
    description: "Exploit a use-after-free vulnerability to get the flag."
  - id: level-2-0
    name: level2.0
    description: "Create and exploit a use-after-free vulnerability to get the flag."
  - id: level-2-1
    name: level2.1
    description: "Create and exploit a use-after-free vulnerability to get the flag."
  - id: level-3-0
    name: level3.0
    description: "Create and exploit a use-after-free vulnerability to get the flag when multiple allocations occur."
  - id: level-3-1
    name: level3.1
    description: "Create and exploit a use-after-free vulnerability to get the flag when multiple allocations occur."
  - id: level-4-0
    name: level4.0
    description: "Corrupt the TCACHE entry_struct value to get the flag when multiple allocations occur."
  - id: level-4-1
    name: level4.1
    description: "Corrupt the TCACHE entry_struct value to get the flag when multiple allocations occur."
  - id: level-5-0
    name: level5.0
    description: "Apply the TCACHE metadata in an unintended manner to set a value."
  - id: level-5-1
    name: level5.1
    description: "Apply the TCACHE metadata in an unintended manner to set a value."
  - id: level-6-0
    name: level6.0
    description: "Corrupt the TCACHE entry_struct to read unintended memory."
  - id: level-6-1
    name: level6.1
    description: "Corrupt the TCACHE entry_struct to read unintended memory."
  - id: level-7-0
    name: level7.0
    description: "Corrupt the TCACHE entry_struct to read unintended memory."
  - id: level-7-1
    name: level7.1
    description: "Corrupt the TCACHE entry_struct to read unintended memory."
  - id: level-8-0
    name: level8.0
    description: "Leverage TCACHE exploits to pass a validation check."
  - id: level-8-1
    name: level8.1
    description: "Leverage TCACHE exploits to pass a validation check."
  - id: level-9-0
    name: level9.0
    description: "Leverage TCACHE exploits to pass a validation check."
  - id: level-9-1
    name: level9.1
    description: "Leverage TCACHE exploits to pass a validation check."
  - id: level-10-0
    name: level10.0
    description: "Leverage TCACHE exploits to gain control flow."
  - id: level-10-1
    name: level10.1
    description: "Leverage TCACHE exploits to gain control flow."
  - id: level-11-0
    name: level11.0
    description: "Leverage TCACHE exploits to gain control flow."
  - id: level-11-1
    name: level11.1
    description: "Leverage TCACHE exploits to gain control flow."
  - id: level-12-0
    name: level12.0
    description: "Leverage TCACHE exploits to cause malloc() to return a stack pointer."
  - id: level-12-1
    name: level12.1
    description: "Leverage TCACHE exploits to cause malloc() to return a stack pointer."
  - id: level-13-0
    name: level13.0
    description: "Leverage calling free() on a stack pointer to read secret data."
  - id: level-13-1
    name: level13.1
    description: "Leverage calling free() on a stack pointer to read secret data."
  - id: level-14-0
    name: level14.0
    description: "Leverage TCACHE exploits to obtain the flag."
  - id: level-14-1
    name: level14.1
    description: "Leverage TCACHE exploits to obtain the flag."
  - id: level-15-0
    name: level15.0
    description: "Leverage TCACHE exploits to obtain the flag."
  - id: level-15-1
    name: level15.1
    description: "Leverage TCACHE exploits to obtain the flag."
  - id: level-16-0
    name: level16.0
    description: "Revisit a prior challenge, now with TCACHE safe-linking."
  - id: level-16-1
    name: level16.1
    description: "Revisit a prior challenge, now with TCACHE safe-linking."
  - id: level-17-0
    name: level17.0
    description: "Revisit a prior challenge, now with TCACHE safe-linking."
  - id: level-17-1
    name: level17.1
    description: "Revisit a prior challenge, now with TCACHE safe-linking."
  - id: level-18-0
    name: level18.0
    description: "Revisit a prior challenge, now with TCACHE safe-linking."
  - id: level-18-1
    name: level18.1
    description: "Revisit a prior challenge, now with TCACHE safe-linking."
  - id: level-19-0
    name: level19.0
    description: "Leverage overlapping allocations to obtain the flag."
  - id: level-19-1
    name: level19.1
    description: "Leverage overlapping allocations to obtain the flag."
  - id: level-20-0
    name: level20.0
    description: "16 bytes and a dream."
  - id: level-20-1
    name: level20.1
    description: "16 bytes and a dream."
- id: dynamic-allocator-exploitation
  name: Dynamic Allocator Exploitation
  description: |
    The glibc heap consists of many components distinct parts that balance performance and security.
    Beyond `tcache` exists a memory management system consisting of many interrelated bins and components.
    This module explores these components and interactions between them.
    By applying advanced heap exploits that "shape" the internal state of the heap, exploitation primitives can be created.
    Heap exploits are complex and ephemeral, frequently changing with libc versions.
    For this reason, success in the module relies on parsing [heap exploit proof of concepts](https://github.com/shellphish/how2heap) to craft an exploit.

  challenges:
  - id: level-1-0
    name: level1.0
    description: "Leverage consolidation to obtain the flag."
  - id: level-1-1
    name: level1.1
    description: "Leverage consolidation to obtain the flag."
  - id: level-2-0
    name: level2.0
    description: "Leverage consolidation to obtain the flag."
  - id: level-2-1
    name: level2.1
    description: "Leverage consolidation to obtain the flag."
  - id: level-3-0
    name: level3.0
    description: "Leverage consolidation to obtain the flag."
  - id: level-3-1
    name: level3.1
    description:  "Leverage consolidation to obtain the flag."
  - id: level-4-0
    name: level4.0
    description: "Perform an advanced heap exploit to obtain the flag"
  - id: level-4-1
    name: level4.1
    description: "Perform an advanced heap exploit to obtain the flag"
  - id: level-5-0
    name: level5.0
    description: "Perform an advanced heap exploit to obtain the flag"
  - id: level-5-1
    name: level5.1
    description: "Perform an advanced heap exploit to obtain the flag"
  - id: level-6-0
    name: level6.0
    description: "Perform an advanced heap exploit to obtain the flag"
  - id: level-6-1
    name: level6.1
    description: "Perform an advanced heap exploit to obtain the flag"
  - id: level-7-0
    name: level7.0
    description: "Perform an advanced heap exploit to obtain the flag"
  - id: level-7-1
    name: level7.1
    description: "Perform an advanced heap exploit to obtain the flag"
  - id: level-8-0
    name: level8.0
    description: "Perform an advanced heap exploit to obtain the flag"
  - id: level-8-1
    name: level8.1
    description: "Perform an advanced heap exploit to obtain the flag"
- id: kernel-security
  name: Kernel Security
  description: The kernel is the core component of an operating system, serving as the bridge between software and hardware. Operating at the lowest level of the OS, the kernel's access is so profound that it can be likened to impersonating the system itself, surpassing even the highest privileges of a root user. Kernel security is paramount because a breach at this level allows attackers to act as if they are the system. Vulnerabilities can lead to scenarios like unauthorized data access, system crashes, or the silent installation of rootkits.
  challenges:
  - id: level-1-0
    name: level1.0
    description: Ease into kernel exploitation with this simple crackme level!
  - id: level-1-1
    name: level1.1
    description: Ease into kernel exploitation with this simple crackme level!
  - id: level-2-0
    name: level2.0
    description: Ease into kernel exploitation with another crackme level.
  - id: level-2-1
    name: level2.1
    description: Ease into kernel exploitation with another crackme level.
  - id: level-3-0
    name: level3.0
    description: Ease into kernel exploitation with another crackme level, this time with some privilege escalation (whoami?).
  - id: level-3-1
    name: level3.1
    description: Ease into kernel exploitation with another crackme level, this time with some privilege escalation (whoami?).
  - id: level-4-0
    name: level4.0
    description: Ease into kernel exploitation with another crackme level and learn how kernel devices communicate.
  - id: level-4-1
    name: level4.1
    description: Ease into kernel exploitation with another crackme level and learn how kernel devices communicate.
  - id: level-5-0
    name: level5.0
    description: Utilize your hacker skillset to communicate with a kernel device and get the flag.
  - id: level-5-1
    name: level5.1
    description: Utilize your hacker skillset to communicate with a kernel device and get the flag.
  - id: level-6-0
    name: level6.0
    description: Utilize a 'buggy' kernel device and shellcode to escalate privileges to root and get the flag!
  - id: level-6-1
    name: level6.1
    description: Utilize a 'buggy' kernel device and shellcode to escalate privileges to root and get the flag!
  - id: level-7-0
    name: level7.0
    description: Utilize a 'buggy' kernel device and shellcode to escalate privileges to root and get the flag!
  - id: level-7-1
    name: level7.1
    description: Utilize a 'buggy' kernel device and shellcode to escalate privileges to root and get the flag!
  - id: level-8-0
    name: level8.0
    description: Utilize a userspace binary to interact with a kernel device.
  - id: level-8-1
    name: level8.1
    description: Utilize a userspace binary to interact with a kernel device.
  - id: level-9-0
    name: level9.0
    description: Exploit a buggy kernel device to get the flag!
  - id: level-9-1
    name: level9.1
    description: Exploit a buggy kernel device to get the flag!
  - id: level-10-0
    name: level10.0
    description: Exploit a buggy kernel device with KASLR enabled to get the flag!
  - id: level-10-1
    name: level10.1
    description: Exploit a buggy kernel device with KASLR enabled to get the flag!
  - id: level-11-0
    name: level11.0
    description: Exploit a kernel device utilizing a userspace binary, with a twist!
  - id: level-11-1
    name: level11.1
    description: Exploit a kernel device utilizing a userspace binary, with a twist!
  - id: level-12-0
    name: level12.0
    description: Exploit a kernel device utilizing a userspace binary, with a twist!
  - id: level-12-1
    name: level12.1
    description: Exploit a kernel device utilizing a userspace binary, with a twist!
- id: system-exploitation
  name: System Exploitation
  description: Step into the realm of system exploitation, where moving from user land to the kernel echoes the fluidity and precision of a martial artist transitioning between stances. In userland, you'll apply foundational techniques, preparing for the strategic leap into the kernel, akin to a perfectly executed flying kick.  You'll land in the kernel with an electrifying strike of technical mastery and strategic brilliance to deliver the final blow.

  challenges:
  - id: level-1-0
    name: level1.0
    description: Take advantage of yan85.. in the kernel!
  - id: level-1-1
    name: level1.1
    description: Take advantage of yan85.. in the kernel!
  - id: level-2-0
    name: level2.0
    description: Defeat yan85's seccomp implementation.
  - id: level-2-1
    name: level2.1
    description: Defeat yan85's seccomp implementation.
  - id: level-3-0
    name: level3.0
    description: Introducing... multiple ypus!
  - id: level-3-1
    name: level3.1
    description: Introducing... multiple ypus!
  - id: level-4-0
    name: level4.0
    description: Exploit a userland binary with mutexes.
  - id: level-4-1
    name: level4.1
    description: Exploit a userland binary with mutexes.
  - id: level-5-0
    name: level5.0
    description: Exploit the userland binary to run multiple ypus.
  - id: level-5-1
    name: level5.1
    description: Exploit the userland binary to run multiple ypus.
  - id: level-6-0
    name: level6.0
    description: Exploit the userland binary to run multiple ypus.
  - id: level-6-1
    name: level6.1
    description: Exploit the userland binary to run multiple ypus.
  - id: level-7-0
    name: level7.0
    description: Circumvent yan85's output sanitization.
  - id: level-7-1
    name: level7.1
    description: Circumvent yan85's output sanitization.
  - id: level-8-0
    name: level8.0
    description: Circumvent yan85's output sanitization with KASLR.
  - id: level-8-1
    name: level8.1
    description: Circumvent yan85's output sanitization with KASLR.
